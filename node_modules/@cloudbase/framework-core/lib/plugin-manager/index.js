"use strict";
/**
 * Tencent is pleased to support the open source community by making CloudBaseFramework - äº‘åŸç”Ÿä¸€ä½“åŒ–éƒ¨ç½²å·¥å…· available.
 *
 * Copyright (C) 2020 THL A29 Limited, a Tencent company.  All rights reserved.
 *
 * Please refer to license text included with this package for license details.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/no-require-imports */
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const corePackageInfo = require('../../package');
const pkg_install_1 = require("./pkg-install");
const emoji_1 = require("../utils/emoji");
const plugin_service_api_1 = __importDefault(require("../plugin-service-api"));
const toolbox_1 = require("@cloudbase/toolbox");
/**
 * æ’ä»¶ç®¡ç†å™¨
 *
 * @description ç®¡ç†æ’ä»¶çš„ç”Ÿå‘½å‘¨æœŸï¼Œä¸ºæ’ä»¶æ³¨å…¥ api å’Œå‚æ•°
 */
class PluginManager {
    constructor(context) {
        this.context = context;
        this.plugins = this.resolvePlugins(this.context.appConfig);
        this.pluginRegistry = path_1.default.join(os_1.default.homedir(), 'cloudbase-framework/registry');
        this.initRegistry();
        this.pluginInstallPromise = this.installPlugins();
    }
    /**
     * åˆå§‹åŒ–æ£€æµ‹
     *
     * @param id
     */
    init(id) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.pluginInstallPromise;
            return this.callPluginHook('init', {
                id,
            });
        });
    }
    /**
     * æ„å»º
     *
     * @param id
     */
    build(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.callPluginHook('build', {
                id,
                icon: emoji_1.emoji('ğŸ”¨'),
            });
        });
    }
    /**
     * ç¼–è¯‘
     *
     * @param id
     */
    compile(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.callPluginHook('compile', {
                id,
                icon: emoji_1.emoji('ğŸ§¬'),
            });
        });
    }
    /**
     * éƒ¨ç½²
     *
     * @param id
     */
    deploy(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.callPluginHook('deploy', {
                id,
                icon: emoji_1.emoji('ğŸš€'),
            });
        });
    }
    /**
     * æ‰§è¡Œæœ¬åœ°å‘½ä»¤
     *
     * @param id
     */
    run(id, runCommandKey) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.callPluginHook('run', {
                id,
                params: { runCommandKey },
                icon: emoji_1.emoji('ğŸš¢'),
            });
        });
    }
    /**
     * è°ƒç”¨æ’ä»¶é’©å­
     * @param id
     */
    callPluginHook(hook, { id, params, icon }) {
        return Promise.all(this.pickPlugins(id).map((pluginData) => __awaiter(this, void 0, void 0, function* () {
            const pluginInstance = yield this.loadPlugin(pluginData);
            if (typeof pluginInstance[hook] !== 'function') {
                return;
            }
            this.context.logger.info(`${icon || emoji_1.emoji('ğŸ”§')} ${hook}: ${pluginData.id}...`);
            return pluginInstance[hook](params);
        })));
    }
    /**
     * è§£ææ’ä»¶
     * @param config
     */
    resolvePlugins(config) {
        const pattern = /^(((@[^/]+)\/)?[^@]+)(@(.*))?$/;
        const allPlugins = Object.entries(config.plugins).map(([id, pluginConfig]) => {
            const { use, inputs } = pluginConfig;
            const matches = pattern.exec(use);
            if (!matches) {
                throw new Error(`é”™è¯¯çš„æ’ä»¶å${use}`);
            }
            const [, pkgName, , scope, , version] = matches;
            return {
                id,
                name: pkgName,
                scope,
                inputs: inputs,
                version,
            };
        });
        return allPlugins;
    }
    /**
     * åŠ è½½æ’ä»¶ä»£ç 
     *
     * @param pluginData
     */
    loadPlugin(pluginData) {
        return __awaiter(this, void 0, void 0, function* () {
            if (pluginData.pluginInstance) {
                return pluginData.pluginInstance;
            }
            let PluginCode;
            yield this.pluginInstallPromise;
            PluginCode = require(path_1.default.join(this.pluginRegistry, 'node_modules', pluginData.name)).plugin;
            if (!PluginCode) {
                this.context.logger.error(`CloudBase Framework: plugin '${pluginData.name}' isn't a valid plugin`);
                throw new Error(`CloudBase Framework: plugin '${pluginData.name}' isn't a valid plugin`);
            }
            pluginData.pluginInstance = new PluginCode(pluginData.name, new plugin_service_api_1.default(this), pluginData.inputs);
            return pluginData.pluginInstance;
        });
    }
    /**
     * ç­›é€‰æ’ä»¶
     * @param id
     */
    pickPlugins(id) {
        return id
            ? this.plugins.filter((plugin) => plugin.id === id)
            : this.plugins;
    }
    /**
     * @param packageName
     */
    installPackage(packageInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            this.context.logger.info(`${emoji_1.emoji('ğŸ“¦')} install plugins`);
            yield pkg_install_1.npmInstallWithCheck(Object.assign({}, packageInfo), {
                cwd: this.pluginRegistry,
            });
        });
    }
    /**
     * åˆå§‹åŒ–æ’ä»¶ä»“åº“
     */
    initRegistry() {
        if (!fs_1.default.existsSync(this.pluginRegistry)) {
            toolbox_1.mkdirSync(this.pluginRegistry);
        }
        const packageJSON = path_1.default.join(this.pluginRegistry, 'package.json');
        if (!fs_1.default.existsSync(packageJSON)) {
            fs_1.default.writeFileSync(packageJSON, JSON.stringify({
                name: 'cloudbase-framework-registry',
            }));
        }
    }
    installPlugins() {
        return __awaiter(this, void 0, void 0, function* () {
            if (process.env.CLOUDBASE_FX_ENV === 'dev') {
                this.context.logger.info('CLOUDBASE_FX_ENV=devæ—¶ï¼Œè¿›å…¥æœ¬åœ°å¼€å‘æ¨¡å¼ï¼Œæ’ä»¶ä½¿ç”¨æœ¬åœ°linkç‰ˆæœ¬');
                return true;
            }
            else {
                const packageInfo = this.plugins.reduce((prev, curr) => {
                    const pkgVersion = curr.version;
                    let version;
                    // å¦‚æŒ‡å®šç‰ˆæœ¬ï¼ŒæŒ‰ç…§æŒ‡å®šçš„ç‰ˆæœ¬
                    if (pkgVersion) {
                        version = pkgVersion;
                        // å®˜æ–¹æ’ä»¶çš„ç‰ˆæœ¬ï¼Œè·Ÿå†…æ ¸ç‰ˆæœ¬ç›¸åŒ
                    }
                    else if (curr.scope === '@cloudbase') {
                        version = corePackageInfo.version;
                    }
                    else {
                        // å…¶ä»–æ’ä»¶ï¼Œå–æœ€æ–°ç‰ˆæœ¬
                        version = 'latest';
                    }
                    prev[curr.name] = version;
                    return prev;
                }, {});
                yield this.installPackage(packageInfo);
                return true;
            }
        });
    }
}
exports.default = PluginManager;
