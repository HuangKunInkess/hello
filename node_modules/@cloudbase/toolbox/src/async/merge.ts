import { nilCache, Cache } from '../cache';

export type PromiseFn<T> = () => Promise<T>

export type CallbackFn = (e: Error, ret: any) => void

export interface IMergeOptions {
    // 缓存时间，默认 0，设置大于 0 的数字，则缓存任务结果
    maxAge?: number

    // 超时时间，默认 60s
    timeout?: number
}

// 使用 Symbol 值，判断缓存结果时，可以准确判断是否为 Error 类型
const ERROR_KEY = Symbol('ERROR_KEY');

/**
 * 异步任务合并
 */
export class AsyncMerge {
    static instance: AsyncMerge = new AsyncMerge()

    static merge<T>(
        fn: PromiseFn<T>,
        taskId: string | number,
        options?: IMergeOptions
    ): Promise<T> {
        return AsyncMerge.instance.merge(fn, taskId, options);
    }

    private tasks: Record<string, { callbacks: Function[]; lock: boolean }> = {}

    merge<T>(fn: PromiseFn<T>, taskId: string | number, options: IMergeOptions = {}): Promise<T> {
        const { maxAge = 0 } = options;

        if (!taskId) {
            throw new Error(
                'AsyncMerge taskId could not be empty, it will cause unexpected result!'
            );
        }

        return new Promise<T>((resolve, reject) => {
            // 取缓存
            const cacheRet = nilCache.get(taskId);

            // 校验缓存，缓存结果可能为 null, undefined 等空值
            // 使用 Symbol 值做判断
            if (maxAge > 0 && cacheRet !== Cache.NIL) {
                const e = cacheRet[ERROR_KEY];
                if (e) {
                    reject(e);
                } else {
                    resolve(cacheRet);
                }
            } else {
                this.runTask(fn, taskId, options, (e, res) => {
                    if (e) {
                        reject(e);
                    } else {
                        resolve(res);
                    }
                });
            }
        });
    }

    // eslint-disable-next-line
    runTask<T>(
        fn: PromiseFn<T>,
        taskId: string | number,
        taskOptions: IMergeOptions,
        cb: CallbackFn
    ) {
        const { tasks } = this;
        const { maxAge = 0, timeout = 60000 } = taskOptions;

        if (!tasks[taskId]) {
            tasks[taskId] = {
                lock: false,
                callbacks: []
            };
        }

        tasks[taskId].callbacks.push(cb);
        const task = tasks[taskId];

        // 当前类型的任务没有运行
        if (!task.lock) {
            let timerId = null;
            if (timeout) {
                timerId = setTimeout(() => {
                    // 超时回调
                    task.callbacks.forEach((cb) => cb(new Error('TASK_TIMEOUT')));
                    task.lock = false;
                    delete tasks[taskId];
                }, timeout);
            }

            // 上锁，标志任务处理开始
            task.lock = true;

            fn()
                .then((res) => {
                    clearTimeout(timerId);
                    task.lock = false;
                    delete tasks[taskId];
                    maxAge > 0 && nilCache.set(taskId, res, maxAge);
                    task.callbacks.forEach((cb) => cb(null, res));
                })
                .catch((e) => {
                    clearTimeout(timerId);
                    task.lock = false;
                    delete tasks[taskId];
                    // 任务异常，缓存异常值
                    maxAge > 0 && nilCache.set(taskId, { ERROR_KEY: e }, maxAge);
                    task.callbacks.forEach((cb) => cb(e));
                });
        }
    }
}
