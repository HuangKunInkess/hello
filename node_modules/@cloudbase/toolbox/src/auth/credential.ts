import { fetch } from '@cloudbase/cloud-api';
import { checkAuth, resolveCredential, resolveWebCredential } from './common';
import { AsyncMerge } from '../async';
import { md5Encoding } from '../coding';
import { getMacAddress } from '../system';
import { LocalStore } from '../localstore';
import { CloudBaseError } from '../error';
import { Credential, WebAuthCredential, RequestConfig } from '../types';

const refreshTokenUrl = 'https://iaas.cloud.tencent.com/tcb_refresh';

export const authStore = new LocalStore<{
    _: string;
    credential: Partial<Credential> & Partial<WebAuthCredential>;
}>(
    {
        _: '这是您的 CloudBase 身份凭据文件，请不要分享给他人！',
        credential: {}
    },
    'auth'
);

export enum ENV_NAME {
    ENV_SECRETID = 'TENCENTCLOUD_SECRETID',
    ENV_SECRETKEY = 'TENCENTCLOUD_SECRETKEY',
    ENV_SESSIONTOKEN = 'TENCENTCLOUD_SESSIONTOKEN',
    ENV_TCB_ENV_ID = 'TENCENTCLOUD_TCB_ENVID',
    ENV_RUNENV = 'TENCENTCLOUD_RUNENV',
    ENV_RUNENV_SCF = 'TENCENTCLOUD_RUNENV=SCF'
}

function resolveCredentialFormEnv(): Credential {
    const getEnvVar = (envName: string): string => {
        return process.env[envName];
    };

    const secretId = getEnvVar(ENV_NAME.ENV_SECRETID);
    const secretKey = getEnvVar(ENV_NAME.ENV_SECRETKEY);
    const token = getEnvVar(ENV_NAME.ENV_SESSIONTOKEN);

    return {
        secretId,
        secretKey,
        token
    };
}

// 获取 credential 数据
export async function getCredentialData(): Promise<Credential> {
    const localData: Credential | WebAuthCredential = (await authStore.get('credential')) as
        | Credential
        | WebAuthCredential;

    const cloudCredentail = resolveCredentialFormEnv();

    const credential: Credential = resolveCredential(localData) || cloudCredentail;

    const keys = Object.keys(credential)
        .filter((key) => credential[key])
        .filter((key) => key !== '-');

    // 检查是否为空对象
    if (!credential || keys.length === 0) {
        return null;
    }

    return credential;
}

// 临时密钥过期后，进行续期
export async function refreshTmpToken(
    metaData: Credential & { isLogout?: boolean }
): Promise<WebAuthCredential> {
    const mac = await getMacAddress();
    const hash = md5Encoding(mac);
    metaData.hash = hash;

    const credential = resolveWebCredential(metaData);

    const res = await AsyncMerge.merge(
        () =>
            fetch(
                refreshTokenUrl,
                {
                    method: 'POST',
                    // 超时时间：15S
                    timeout: 15000,
                    body: JSON.stringify(credential),
                    headers: { 'Content-Type': 'application/json' }
                },
                ''
            ),
        'refreshToken',
        {
            maxAge: 5000
        }
    );

    if (res.code !== 0) {
        throw new CloudBaseError(res.message, {
            action: 'RefreshAccessToken',
            code: res.code
        });
    }

    const { data } = res;

    return data;
}

// 是否为 CAM 权限错误
export const isCamRefused = (e: CloudBaseError) => {
    return (
        Number(e.code) === 4102 ||
        Number(e.code) === 42 ||
        e.code === 'UnauthorizedOperation' ||
        e.code === 'AuthFailure.UnauthorizedOperation'
    );
};

// 报错返回 null 值
async function wrapCheckAuth(credential: Credential, options: RequestConfig) {
    const { timeout = 15000 } = options;
    try {
        // 合并请求，避免超过接口限频
        await AsyncMerge.merge(() => checkAuth(credential, options), 'checkAuth', {
            // 超时时间不能小于发送请求的超时时间
            timeout: Number(timeout) ? (timeout < 15000 ? 15000 : timeout + 1000) : 15000
        });
        return credential;
    } catch (e) {
        // CAM 错误视为登录正常
        if (isCamRefused(e)) return credential;

        // 请求超时
        if (e.type === 'request-timeout') {
            throw new CloudBaseError(
                '请求超时，请检查你的网络，如果终端无法直接访问公网，请设置终端 HTTP 请求代理！'
            );
        }
        return null;
    }
}

// token 将在 n 分钟内过期
const isTokenExpired = (credential: Credential, gap = 120) =>
    credential.accessTokenExpired &&
    Number(credential.accessTokenExpired) < Date.now() + gap * 1000;

// 获取身份认证信息并校验、自动刷新
export async function checkAndGetCredential(options: RequestConfig = {}): Promise<Credential> {
    // 从本地存储中读取 credential
    const credential = await getCredentialData();

    if (!credential) {
        return null;
    }

    // 存在临时密钥信息
    if (credential.refreshToken) {
        // 临时密钥在 2 小时有效期内，可以直接使用
        if (!isTokenExpired(credential)) {
            // 检查 credential
            return wrapCheckAuth(credential, options);
        } else if (Date.now() < Number(credential.expired)) {
            // 临时密钥超过两小时有效期，但在 1 个月 refresh 有效期内，刷新临时密钥
            let refreshCredential: WebAuthCredential;
            try {
                refreshCredential = await refreshTmpToken(credential);
            } catch (e) {
                // 登录态失效
                if (e.code === 'AUTH_FAIL') {
                    return null;
                } else if (e.code === 'InternalError.GetRoleError') {
                    // 用户未开通服务，视为登录态失效
                    return null;
                } else {
                    // 异常错误
                    throw e;
                }
            }
            // 存储新的秘钥
            await authStore.set('credential', refreshCredential || {});
            return wrapCheckAuth(resolveCredential(refreshCredential), options);
        }
    }

    // 存在永久密钥
    if (credential.secretId && credential.secretKey) {
        return wrapCheckAuth(credential, options);
    }

    return null;
}

// 获取身份认证信息，不校验
export async function getCredentialWithoutCheck(): Promise<Credential> {
    const credential = await getCredentialData();
    if (!credential) {
        return null;
    }

    // 存在临时密钥信息
    if (credential.refreshToken) {
        // 临时密钥在 2 小时有效期内，可以直接使用
        if (!isTokenExpired(credential)) {
            return credential;
        } else if (Date.now() < Number(credential.expired)) {
            // 临时密钥超过两小时有效期，但在 1 个月 refresh 有效期内，刷新临时密钥
            let refreshCredential: WebAuthCredential;
            try {
                refreshCredential = await refreshTmpToken(credential);
            } catch (e) {
                // 登录态失效
                if (e.code === 'AUTH_FAIL') {
                    return null;
                } else if (e.code === 'InternalError.GetRoleError') {
                    // 用户未开通服务，视为登录态失效
                    return null;
                } else {
                    // 异常错误
                    throw e;
                }
            }
            // 存储新的秘钥
            await authStore.set('credential', refreshCredential || {});
            return resolveCredential(refreshCredential);
        }
    }

    // 存在永久密钥
    if (credential.secretId && credential.secretKey) {
        return credential;
    }

    return null;
}
