import { getAuthTokenFromWeb } from './web-auth';
import { checkAuth, resolveWebCredential } from './common';
import {
    authStore,
    refreshTmpToken,
    checkAndGetCredential,
    getCredentialWithoutCheck,
    isCamRefused
} from './credential';
import { Credential, RequestConfig } from '../types';
import { CloudBaseError } from '../error';

export * from './common';
export * from './credential';
export * from './web-auth';

export interface AuthSupevisorOptions {
    // 是否在内存中缓存 credential 信息
    cache?: boolean
    // 代理配置
    proxy?: string
    // 请求超时时间
    timeout?: number
}

export interface WebAuthOptions {
    //
    throwError?: boolean
    getAuthUrl?: (rawUrl: string) => string
}

export class AuthSupevisor {
    static instance: AuthSupevisor
    /**
     * 单例模式，全局缓存
     * @param options
     */
    static getInstance(options: AuthSupevisorOptions = {}) {
        if (AuthSupevisor.instance) {
            return AuthSupevisor.instance;
        }
        const instance = new AuthSupevisor(options);
        AuthSupevisor.instance = instance;
        return instance;
    }

    // 缓存结果
    cacheCredential: Credential
    // 是否需要缓存
    needCache: boolean
    // 缓存过期时间
    cacheExpiredTime: number
    // 请求配置
    requestConfig: RequestConfig

    constructor(options: AuthSupevisorOptions = {}) {
        const { cache, proxy, timeout = 15000 } = options;
        this.requestConfig = {
            proxy,
            timeout
        };
        this.needCache = cache;
        this.cacheExpiredTime = 0;
    }

    /**
     * 获取登录状态信息
     */
    async getLoginState(): Promise<Credential> {
        if (this.cacheCredential && this.needCache && !this.isCacheExpire()) {
            return this.cacheCredential;
        }

        // 获取本地登录状态
        const credential: Credential = await checkAndGetCredential(this.requestConfig);

        if (this.needCache && credential) {
            this.cacheCredential = credential;
            const { accessTokenExpired } = credential;
            this.cacheExpiredTime = accessTokenExpired
                ? Number(accessTokenExpired)
                : Date.now() + 3600 * 1000;
        }

        return credential;
    }

    /**
     * 通过网页授权登录
     * @returns credential
     */
    async loginByWebAuth(options: WebAuthOptions = {}): Promise<Credential> {
        const { getAuthUrl, throwError } = options;

        if (this.cacheCredential && this.needCache && !this.isCacheExpire()) {
            return this.cacheCredential;
        }

        // 校验本地秘钥
        let credential: Credential = await checkAndGetCredential(this.requestConfig);
        if (credential) return credential;

        // 兼容临时秘钥
        credential = await getAuthTokenFromWeb({
            getAuthUrl
        });

        try {
            await checkAuth(credential, this.requestConfig);
        } catch (error) {
            if (throwError) {
                throw error;
            }
            return null;
        }

        // 通过 Web 登录时，本地要存储 tmpSecretId 形式，方式 CLI 登录失效
        const webCredential = resolveWebCredential(credential);
        await authStore.set('credential', webCredential);

        // 缓存处理转换后的 credential
        if (this.needCache && credential) {
            this.cacheCredential = credential;
            const { accessTokenExpired } = credential;

            this.cacheExpiredTime = accessTokenExpired
                ? Number(accessTokenExpired)
                : Date.now() + 3600 * 1000;
        }

        return credential;
    }

    /**
     * 通过 API Secret 登录，支持临时秘钥
     * @param secretId
     * @param secretKey
     * @param token
     * @returns credential
     */
    async loginByApiSecret(
        secretId?: string,
        secretKey?: string,
        token?: string
    ): Promise<Credential> {
        if (this.cacheCredential && this.needCache && !this.isCacheExpire()) {
            return this.cacheCredential;
        }

        // 校验本地秘钥
        let credential: Credential = await checkAndGetCredential(this.requestConfig);
        if (credential) return credential;

        // 当本地身份信息不存在时，才使用传入参数进行校验
        if (!secretId || !secretKey) {
            throw new CloudBaseError('secretId 或 secretKey 不能为空');
        }

        credential = {
            secretId,
            secretKey,
            token
        };

        try {
            await checkAuth(credential, this.requestConfig);
        } catch (e) {
            // CAM 错误视为登录正常
            if (isCamRefused(e)) return credential;

            // 请求超时
            if (e.type === 'request-timeout') {
                throw new CloudBaseError(
                    '请求超时，请检查你的网络，如果终端无法直接访问公网，请设置终端 HTTP 请求代理！'
                );
            }

            return null;
        }

        // 存储信息
        await authStore.set('credential', credential);

        if (this.needCache && credential) {
            this.cacheCredential = credential;
            this.cacheExpiredTime = Date.now() + 3600 * 1000;
        }

        return credential;
    }

    async logout() {
        if (this.cacheCredential) {
            this.cacheCredential = null;
        }
        const credentail: Credential = await getCredentialWithoutCheck();

        try {
            // 仅使用 Web 控制台授权登录时才删除 token
            if (credentail?.refreshToken) {
                await refreshTmpToken({
                    ...credentail,
                    isLogout: true
                });
            }
            await authStore.delete('credential');
        } catch (e) {
            await authStore.delete('credential');
        }
    }

    private isCacheExpire(): boolean {
        const now = Date.now();
        this.cacheExpiredTime = this.cacheExpiredTime || 0;
        return now >= this.cacheExpiredTime;
    }
}
