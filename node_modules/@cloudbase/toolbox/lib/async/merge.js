"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AsyncMerge = void 0;
const cache_1 = require("../cache");
const ERROR_KEY = Symbol('ERROR_KEY');
class AsyncMerge {
    constructor() {
        this.tasks = {};
    }
    static merge(fn, taskId, options) {
        return AsyncMerge.instance.merge(fn, taskId, options);
    }
    merge(fn, taskId, options = {}) {
        const { maxAge = 0 } = options;
        if (!taskId) {
            throw new Error('AsyncMerge taskId could not be empty, it will cause unexpected result!');
        }
        return new Promise((resolve, reject) => {
            const cacheRet = cache_1.nilCache.get(taskId);
            if (maxAge > 0 && cacheRet !== cache_1.Cache.NIL) {
                const e = cacheRet[ERROR_KEY];
                if (e) {
                    reject(e);
                }
                else {
                    resolve(cacheRet);
                }
            }
            else {
                this.runTask(fn, taskId, options, (e, res) => {
                    if (e) {
                        reject(e);
                    }
                    else {
                        resolve(res);
                    }
                });
            }
        });
    }
    runTask(fn, taskId, taskOptions, cb) {
        const { tasks } = this;
        const { maxAge = 0, timeout = 60000 } = taskOptions;
        if (!tasks[taskId]) {
            tasks[taskId] = {
                lock: false,
                callbacks: []
            };
        }
        tasks[taskId].callbacks.push(cb);
        const task = tasks[taskId];
        if (!task.lock) {
            let timerId = null;
            if (timeout) {
                timerId = setTimeout(() => {
                    task.callbacks.forEach((cb) => cb(new Error('TASK_TIMEOUT')));
                    task.lock = false;
                    delete tasks[taskId];
                }, timeout);
            }
            task.lock = true;
            fn()
                .then((res) => {
                clearTimeout(timerId);
                task.lock = false;
                delete tasks[taskId];
                maxAge > 0 && cache_1.nilCache.set(taskId, res, maxAge);
                task.callbacks.forEach((cb) => cb(null, res));
            })
                .catch((e) => {
                clearTimeout(timerId);
                task.lock = false;
                delete tasks[taskId];
                maxAge > 0 && cache_1.nilCache.set(taskId, { ERROR_KEY: e }, maxAge);
                task.callbacks.forEach((cb) => cb(e));
            });
        }
    }
}
exports.AsyncMerge = AsyncMerge;
AsyncMerge.instance = new AsyncMerge();
