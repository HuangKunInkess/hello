"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthSupevisor = void 0;
const web_auth_1 = require("./web-auth");
const common_1 = require("./common");
const credential_1 = require("./credential");
const error_1 = require("../error");
__exportStar(require("./common"), exports);
__exportStar(require("./credential"), exports);
__exportStar(require("./web-auth"), exports);
class AuthSupevisor {
    constructor(options = {}) {
        const { cache, proxy, timeout = 15000 } = options;
        this.requestConfig = {
            proxy,
            timeout
        };
        this.needCache = cache;
        this.cacheExpiredTime = 0;
    }
    static getInstance(options = {}) {
        if (AuthSupevisor.instance) {
            return AuthSupevisor.instance;
        }
        const instance = new AuthSupevisor(options);
        AuthSupevisor.instance = instance;
        return instance;
    }
    getLoginState() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.cacheCredential && this.needCache && !this.isCacheExpire()) {
                return this.cacheCredential;
            }
            const credential = yield credential_1.checkAndGetCredential(this.requestConfig);
            if (this.needCache && credential) {
                this.cacheCredential = credential;
                const { accessTokenExpired } = credential;
                this.cacheExpiredTime = accessTokenExpired
                    ? Number(accessTokenExpired)
                    : Date.now() + 3600 * 1000;
            }
            return credential;
        });
    }
    loginByWebAuth(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { getAuthUrl, throwError } = options;
            if (this.cacheCredential && this.needCache && !this.isCacheExpire()) {
                return this.cacheCredential;
            }
            let credential = yield credential_1.checkAndGetCredential(this.requestConfig);
            if (credential)
                return credential;
            credential = yield web_auth_1.getAuthTokenFromWeb({
                getAuthUrl
            });
            try {
                yield common_1.checkAuth(credential, this.requestConfig);
            }
            catch (error) {
                if (throwError) {
                    throw error;
                }
                return null;
            }
            const webCredential = common_1.resolveWebCredential(credential);
            yield credential_1.authStore.set('credential', webCredential);
            if (this.needCache && credential) {
                this.cacheCredential = credential;
                const { accessTokenExpired } = credential;
                this.cacheExpiredTime = accessTokenExpired
                    ? Number(accessTokenExpired)
                    : Date.now() + 3600 * 1000;
            }
            return credential;
        });
    }
    loginByApiSecret(secretId, secretKey, token) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.cacheCredential && this.needCache && !this.isCacheExpire()) {
                return this.cacheCredential;
            }
            let credential = yield credential_1.checkAndGetCredential(this.requestConfig);
            if (credential)
                return credential;
            if (!secretId || !secretKey) {
                throw new error_1.CloudBaseError('secretId 或 secretKey 不能为空');
            }
            credential = {
                secretId,
                secretKey,
                token
            };
            try {
                yield common_1.checkAuth(credential, this.requestConfig);
            }
            catch (e) {
                if (credential_1.isCamRefused(e))
                    return credential;
                if (e.type === 'request-timeout') {
                    throw new error_1.CloudBaseError('请求超时，请检查你的网络，如果终端无法直接访问公网，请设置终端 HTTP 请求代理！');
                }
                return null;
            }
            yield credential_1.authStore.set('credential', credential);
            if (this.needCache && credential) {
                this.cacheCredential = credential;
                this.cacheExpiredTime = Date.now() + 3600 * 1000;
            }
            return credential;
        });
    }
    logout() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.cacheCredential) {
                this.cacheCredential = null;
            }
            const credentail = yield credential_1.getCredentialWithoutCheck();
            try {
                if (credentail === null || credentail === void 0 ? void 0 : credentail.refreshToken) {
                    yield credential_1.refreshTmpToken(Object.assign(Object.assign({}, credentail), { isLogout: true }));
                }
                yield credential_1.authStore.delete('credential');
            }
            catch (e) {
                yield credential_1.authStore.delete('credential');
            }
        });
    }
    isCacheExpire() {
        const now = Date.now();
        this.cacheExpiredTime = this.cacheExpiredTime || 0;
        return now >= this.cacheExpiredTime;
    }
}
exports.AuthSupevisor = AuthSupevisor;
