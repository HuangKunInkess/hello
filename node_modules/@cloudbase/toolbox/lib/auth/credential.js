"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCredentialWithoutCheck = exports.checkAndGetCredential = exports.isCamRefused = exports.refreshTmpToken = exports.getCredentialData = exports.ENV_NAME = exports.authStore = void 0;
const cloud_api_1 = require("@cloudbase/cloud-api");
const common_1 = require("./common");
const async_1 = require("../async");
const coding_1 = require("../coding");
const system_1 = require("../system");
const localstore_1 = require("../localstore");
const error_1 = require("../error");
const refreshTokenUrl = 'https://iaas.cloud.tencent.com/tcb_refresh';
exports.authStore = new localstore_1.LocalStore({
    _: '这是您的 CloudBase 身份凭据文件，请不要分享给他人！',
    credential: {}
}, 'auth');
var ENV_NAME;
(function (ENV_NAME) {
    ENV_NAME["ENV_SECRETID"] = "TENCENTCLOUD_SECRETID";
    ENV_NAME["ENV_SECRETKEY"] = "TENCENTCLOUD_SECRETKEY";
    ENV_NAME["ENV_SESSIONTOKEN"] = "TENCENTCLOUD_SESSIONTOKEN";
    ENV_NAME["ENV_TCB_ENV_ID"] = "TENCENTCLOUD_TCB_ENVID";
    ENV_NAME["ENV_RUNENV"] = "TENCENTCLOUD_RUNENV";
    ENV_NAME["ENV_RUNENV_SCF"] = "TENCENTCLOUD_RUNENV=SCF";
})(ENV_NAME = exports.ENV_NAME || (exports.ENV_NAME = {}));
function resolveCredentialFormEnv() {
    const getEnvVar = (envName) => {
        return process.env[envName];
    };
    const secretId = getEnvVar(ENV_NAME.ENV_SECRETID);
    const secretKey = getEnvVar(ENV_NAME.ENV_SECRETKEY);
    const token = getEnvVar(ENV_NAME.ENV_SESSIONTOKEN);
    return {
        secretId,
        secretKey,
        token
    };
}
function getCredentialData() {
    return __awaiter(this, void 0, void 0, function* () {
        const localData = (yield exports.authStore.get('credential'));
        const cloudCredentail = resolveCredentialFormEnv();
        const credential = common_1.resolveCredential(localData) || cloudCredentail;
        const keys = Object.keys(credential)
            .filter((key) => credential[key])
            .filter((key) => key !== '-');
        if (!credential || keys.length === 0) {
            return null;
        }
        return credential;
    });
}
exports.getCredentialData = getCredentialData;
function refreshTmpToken(metaData) {
    return __awaiter(this, void 0, void 0, function* () {
        const mac = yield system_1.getMacAddress();
        const hash = coding_1.md5Encoding(mac);
        metaData.hash = hash;
        const credential = common_1.resolveWebCredential(metaData);
        const res = yield async_1.AsyncMerge.merge(() => cloud_api_1.fetch(refreshTokenUrl, {
            method: 'POST',
            timeout: 15000,
            body: JSON.stringify(credential),
            headers: { 'Content-Type': 'application/json' }
        }, ''), 'refreshToken', {
            maxAge: 5000
        });
        if (res.code !== 0) {
            throw new error_1.CloudBaseError(res.message, {
                action: 'RefreshAccessToken',
                code: res.code
            });
        }
        const { data } = res;
        return data;
    });
}
exports.refreshTmpToken = refreshTmpToken;
const isCamRefused = (e) => {
    return (Number(e.code) === 4102 ||
        Number(e.code) === 42 ||
        e.code === 'UnauthorizedOperation' ||
        e.code === 'AuthFailure.UnauthorizedOperation');
};
exports.isCamRefused = isCamRefused;
function wrapCheckAuth(credential, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const { timeout = 15000 } = options;
        try {
            yield async_1.AsyncMerge.merge(() => common_1.checkAuth(credential, options), 'checkAuth', {
                timeout: Number(timeout) ? (timeout < 15000 ? 15000 : timeout + 1000) : 15000
            });
            return credential;
        }
        catch (e) {
            if (exports.isCamRefused(e))
                return credential;
            if (e.type === 'request-timeout') {
                throw new error_1.CloudBaseError('请求超时，请检查你的网络，如果终端无法直接访问公网，请设置终端 HTTP 请求代理！');
            }
            return null;
        }
    });
}
const isTokenExpired = (credential, gap = 120) => credential.accessTokenExpired &&
    Number(credential.accessTokenExpired) < Date.now() + gap * 1000;
function checkAndGetCredential(options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const credential = yield getCredentialData();
        if (!credential) {
            return null;
        }
        if (credential.refreshToken) {
            if (!isTokenExpired(credential)) {
                return wrapCheckAuth(credential, options);
            }
            else if (Date.now() < Number(credential.expired)) {
                let refreshCredential;
                try {
                    refreshCredential = yield refreshTmpToken(credential);
                }
                catch (e) {
                    if (e.code === 'AUTH_FAIL') {
                        return null;
                    }
                    else if (e.code === 'InternalError.GetRoleError') {
                        return null;
                    }
                    else {
                        throw e;
                    }
                }
                yield exports.authStore.set('credential', refreshCredential || {});
                return wrapCheckAuth(common_1.resolveCredential(refreshCredential), options);
            }
        }
        if (credential.secretId && credential.secretKey) {
            return wrapCheckAuth(credential, options);
        }
        return null;
    });
}
exports.checkAndGetCredential = checkAndGetCredential;
function getCredentialWithoutCheck() {
    return __awaiter(this, void 0, void 0, function* () {
        const credential = yield getCredentialData();
        if (!credential) {
            return null;
        }
        if (credential.refreshToken) {
            if (!isTokenExpired(credential)) {
                return credential;
            }
            else if (Date.now() < Number(credential.expired)) {
                let refreshCredential;
                try {
                    refreshCredential = yield refreshTmpToken(credential);
                }
                catch (e) {
                    if (e.code === 'AUTH_FAIL') {
                        return null;
                    }
                    else if (e.code === 'InternalError.GetRoleError') {
                        return null;
                    }
                    else {
                        throw e;
                    }
                }
                yield exports.authStore.set('credential', refreshCredential || {});
                return common_1.resolveCredential(refreshCredential);
            }
        }
        if (credential.secretId && credential.secretKey) {
            return credential;
        }
        return null;
    });
}
exports.getCredentialWithoutCheck = getCredentialWithoutCheck;
