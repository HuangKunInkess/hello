"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getExtensionDescription = exports.ExplorerBase = void 0;
const path_1 = __importDefault(require("path"));
const loaders_1 = require("./loaders");
const getPropertyByPath_1 = require("./getPropertyByPath");
class ExplorerBase {
    constructor(options) {
        if (options.cache === true) {
            this.loadCache = new Map();
            this.searchCache = new Map();
        }
        this.config = options;
        this.validateConfig();
    }
    clearLoadCache() {
        if (this.loadCache) {
            this.loadCache.clear();
        }
    }
    clearSearchCache() {
        if (this.searchCache) {
            this.searchCache.clear();
        }
    }
    clearCaches() {
        this.clearLoadCache();
        this.clearSearchCache();
    }
    getLoaderEntryForFile(filepath) {
        if (path_1.default.basename(filepath) === 'package.json') {
            const loader = this.loadPackageProp.bind(this);
            return loader;
        }
        const loaderKey = path_1.default.extname(filepath) || 'noExt';
        const loader = this.config.loaders[loaderKey];
        if (!loader) {
            throw new Error(`No loader specified for ${getExtensionDescription(filepath)}`);
        }
        return loader;
    }
    loadedContentToCosmiconfigResult(filepath, loadedContent) {
        if (loadedContent === null) {
            return null;
        }
        if (loadedContent === undefined) {
            return { filepath, config: undefined, isEmpty: true };
        }
        return { config: loadedContent, filepath };
    }
    validateFilePath(filepath) {
        if (!filepath) {
            throw new Error('load must pass a non-empty string');
        }
    }
    shouldSearchStopWithResult(result) {
        if (result === null)
            return false;
        if (result.isEmpty && this.config.ignoreEmptySearchPlaces)
            return false;
        return true;
    }
    nextDirectoryToSearch(currentDir, currentResult) {
        if (this.shouldSearchStopWithResult(currentResult)) {
            return null;
        }
        const nextDir = nextDirUp(currentDir);
        if (nextDir === currentDir || currentDir === this.config.stopDir) {
            return null;
        }
        return nextDir;
    }
    validateConfig() {
        const config = this.config;
        config.searchPlaces.forEach((place) => {
            const loaderKey = path_1.default.extname(place) || 'noExt';
            const loader = config.loaders[loaderKey];
            if (!loader) {
                throw new Error(`No loader specified for ${getExtensionDescription(place)}, so searchPlaces item "${place}" is invalid`);
            }
            if (typeof loader !== 'function') {
                throw new Error(`loader for ${getExtensionDescription(place)} is not a function (type provided: "${typeof loader}"), so searchPlaces item "${place}" is invalid`);
            }
        });
    }
    loadPackageProp(filepath, content) {
        const parsedContent = loaders_1.loaders.loadJson(filepath, content);
        const packagePropValue = getPropertyByPath_1.getPropertyByPath(parsedContent, this.config.packageProp);
        return packagePropValue || null;
    }
}
exports.ExplorerBase = ExplorerBase;
function nextDirUp(dir) {
    return path_1.default.dirname(dir);
}
function getExtensionDescription(filepath) {
    const ext = path_1.default.extname(filepath);
    return ext ? `extension "${ext}"` : 'files without extensions';
}
exports.getExtensionDescription = getExtensionDescription;
